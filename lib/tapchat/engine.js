// Generated by CoffeeScript 1.3.3
(function() {
  var B, BacklogDB, Base64, Buffer, CoffeeScript, Config, Connection, Daemon, DataBuffer, Engine, Express, Fs, Http, PasswordHash, Path, PushClient, Url, Util, WebSocket, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, _, _ref;

  Path = require('path');

  Fs = require('fs');

  WorkingQueue = require('capisce').WorkingQueue;

  Http = require('http');

  Express = require('express');

  Url = require('url');

  WebSocket = require('faye-websocket');

  PasswordHash = require('password-hash');

  CoffeeScript = require('coffee-script');

  Util = require('util');

  Daemon = require('daemon');

  _ = require('underscore');

  DataBuffer = require('buffer').Buffer;

  Base64 = require('../base64');

  Config = require('./config');

  B = require('./message_builder');

  Buffer = require('./buffer');

  Connection = require('./connection');

  BacklogDB = require('./backlog_db');

  PushClient = require('./push_client');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  Engine = (function() {

    function Engine(config, callback) {
      var _this = this;
      this.connections = [];
      this.clients = [];
      this.password = config.password;
      this.port = config.port;
      if (!PasswordHash.isHashed(this.password)) {
        throw 'No password set!';
      }
      this.pushId = config.push_id;
      this.pushKey = new DataBuffer(config.push_key, 'base64');
      this.pushClient = new PushClient(this);
      this.db = new BacklogDB(this, function() {
        _this.startServer(_this.port, callback);
        return _this.db.selectConnections(function(conns) {
          var connInfo, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = conns.length; _i < _len; _i++) {
            connInfo = conns[_i];
            _results.push(_this.addConnection(connInfo));
          }
          return _results;
        });
      });
    }

    Engine.prototype.daemonize = function() {
      var logfile, pidfile;
      logfile = Config.getLogFile();
      pidfile = Config.getPidFile();
      this.pid = Daemon.daemonize(logfile, pidfile);
      return console.log('Daemon started successfully with pid:', this.pid);
    };

    Engine.prototype.startServer = function(port, callback) {
      var _this = this;
      this.app = Express.createServer({
        key: Fs.readFileSync(Config.getCertFile()),
        cert: Fs.readFileSync(Config.getCertFile())
      });
      this.app.use(Express["static"](__dirname + '/../../web'));
      this.app.set('views', __dirname + '/../../web');
      this.app.set('view engine', 'html.eco');
      this.app.register('.html.eco', require('eco'));
      this.app.get('/', function(req, res) {
        return res.render('index', {
          layout: false,
          num_clients: _this.clients.length,
          num_connections: _this.connections.length
        });
      });
      this.app.addListener('upgrade', function(request, socket, head) {
        var query, ws;
        query = Url.parse(request.url, true).query;
        if (!PasswordHash.verify(query.password, _this.password)) {
          console.log('bad password');
          request.socket.end('HTTP/1.1 403 Bad password\r\n\r\n');
          return;
        }
        ws = new WebSocket(request, socket, head);
        console.log('websocket client: connected');
        return _this.addClient(ws);
      });
      return this.app.listen(port, function() {
        console.log("\nTapChat ready at https://localhost:" + port + "\n");
        if (callback) {
          return callback(_this);
        }
      });
    };

    Engine.prototype.addClient = function(client) {
      var _this = this;
      client.sendQueue = new WorkingQueue(1);
      this.clients.push(client);
      client.onmessage = function(event) {
        var callback, handler, message;
        message = JSON.parse(event.data);
        if (!message._reqid) {
          console.log('Missing _reqid, ignoring message', event.data);
          return;
        }
        console.log('Got message:', event.data);
        callback = function(reply) {
          return _this.send(client, {
            _reqid: message._reqid,
            msg: merge(reply, {
              success: true
            })
          });
        };
        if (handler = _this.messageHandlers[message._method]) {
          try {
            return handler.apply(_this, [client, message, callback]);
          } catch (error) {
            console.log("Error handling message", error, event.data, error.stack);
            return client.close();
          }
        } else {
          return console.log("No handler for " + message._method);
        }
      };
      client.onclose = function(event) {
        var index;
        console.log('websocket client: disconnected', event.code, event.reason);
        index = _this.clients.indexOf(client);
        return _this.clients.splice(index, 1);
      };
      return this.sendBacklog(client);
    };

    Engine.prototype.send = function(client, message, cb) {
      var _this = this;
      message = this.prepareMessage(message);
      client.sendQueue.perform(function(over) {
        return client.send(JSON.stringify(message), cb ? cb() : void 0, over());
      });
      return message;
    };

    Engine.prototype.prepareMessage = function(message) {
      if (!message.time) {
        message.time = Date.now();
      }
      if (!message.highlight) {
        message.highlight = false;
      }
      if (!message.eid) {
        message.eid = -1;
      }
      return message;
    };

    Engine.prototype.addConnection = function(options) {
      var _this = this;
      return new Connection(this, options, function(conn) {
        _this.connections.push(conn);
        conn.addListener('event', function(event) {
          return _this.broadcast(event);
        });
        return conn.sendBacklog(null, function() {
          if (conn.autoConnect) {
            return conn.connect();
          }
        });
      });
    };

    Engine.prototype.removeConnection = function(conn, cb) {
      var _this = this;
      return conn["delete"](function() {
        _this.connections.splice(_this.connections.indexOf(conn), 1);
        _this.broadcast(B.connectionDeleted(conn));
        return cb();
      });
    };

    Engine.prototype.findConnection = function(cid) {
      var conn, _i, _len, _ref1;
      _ref1 = this.connections;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        if (conn.id === cid) {
          return conn;
        }
      }
      return null;
    };

    Engine.prototype.broadcast = function(message, cb) {
      var client, queue, _fn, _i, _len, _ref1,
        _this = this;
      queue = new WorkingQueue(this.clients.length + 1);
      if (!message.is_backlog) {
        if (message.highlight) {
          queue.perform(function(over) {
            return _this.pushClient.sendPush(message, over);
          });
        }
      }
      _ref1 = this.clients;
      _fn = function(client) {
        return queue.perform(function(over) {
          return _this.send(client, message, over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        client = _ref1[_i];
        _fn(client);
      }
      queue.whenDone(function() {
        if (cb) {
          return cb();
        }
      });
      queue.doneAddingJobs();
      return message;
    };

    Engine.prototype.sendBacklog = function(client) {
      var conn, queue, _fn, _i, _len, _ref1,
        _this = this;
      queue = new WorkingQueue(1);
      queue.perform(function(over) {
        return _this.send(client, {
          type: 'header',
          version: Config.getAppVersion(),
          idle_interval: 29000,
          push_id: _this.pushId,
          push_key: Base64.urlEncode(_this.pushKey)
        }, over);
      });
      _ref1 = this.connections;
      _fn = function(conn) {
        return queue.perform(function(over) {
          return conn.sendBacklog(client, over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        _fn(conn);
      }
      queue.whenDone(function() {
        return _this.send(client, {
          type: 'backlog_complete'
        });
      });
      return queue.doneAddingJobs();
    };

    Engine.prototype.messageHandlers = {
      heartbeat: function(client, message, callback) {
        var bid, buffer, buffers, cid, connection, eid, queue, seenEids, _fn,
          _this = this;
        this.selectedBid = message.selectedBuffer;
        seenEids = JSON.parse(message.seenEids);
        queue = new WorkingQueue(1);
        for (cid in seenEids) {
          buffers = seenEids[cid];
          connection = this.findConnection(parseInt(cid));
          if (!connection) {
            throw "connection not found: " + cid;
          }
          _fn = function(buffer, eid) {
            return queue.perform(function(over) {
              return buffer.setLastSeenEid(eid, over);
            });
          };
          for (bid in buffers) {
            eid = buffers[bid];
            buffer = connection.findBuffer(parseInt(bid));
            if (!buffer) {
              throw "buffer not found: " + bid;
            }
            _fn(buffer, eid);
          }
        }
        queue.whenDone(function() {
          return _this.db.getAllLastSeenEids(function(updatedSeenEids) {
            return _this.send(client, {
              type: 'heartbeat_echo',
              seenEids: updatedSeenEids
            });
          });
        });
        return queue.doneAddingJobs();
      },
      say: function(client, message, callback) {
        var conn, text, to;
        conn = this.findConnection(message.cid);
        to = message.to;
        text = message.msg;
        if (text) {
          conn.say(to, text);
          return;
        }
        return conn.getOrCreateBuffer(to, Buffer.prototype.TYPE_QUERY, function(buffer, created) {
          return callback({
            name: to,
            cid: conn.id,
            type: 'open_buffer',
            _reqid: message._reqid
          });
        });
      },
      join: function(client, message, callback) {
        var chan, conn;
        chan = message.channel;
        conn = this.findConnection(message.cid);
        conn.join(chan);
        return callback({
          name: chan,
          cid: conn.id,
          type: 'open_buffer'
        });
      },
      part: function(client, message, callback) {
        var conn;
        conn = this.findConnection(message.cid);
        conn.part(message.channel);
        return callback();
      },
      disconnect: function(client, message, callback) {
        return this.findConnection(message.cid).disconnect(function() {
          return callback();
        });
      },
      reconnect: function(client, message, callback) {
        var _this = this;
        return this.findConnection(message.cid).reconnect(function() {
          return callback();
        });
      },
      'add-server': function(client, message, callback) {
        var _this = this;
        return this.db.insertConnection(message, function(info) {
          _this.addConnection(info);
          return callback();
        });
      },
      'edit-server': function(client, message, callback) {
        var conn;
        conn = this.findConnection(message.cid);
        return conn.edit(message, callback);
      },
      'delete-connection': function(client, message, callback) {
        var conn;
        conn = this.findConnection(message.cid);
        return this.removeConnection(conn, callback);
      },
      'archive-buffer': function(client, message, callback) {
        var buffer, conn;
        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.archive(callback);
      },
      'unarchive-buffer': function(client, message, callback) {
        var buffer, conn;
        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.unarchive(callback);
      },
      'delete-buffer': function(client, message, callback) {
        var buffer, conn;
        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer["delete"](callback);
      }
    };

    return Engine;

  })();

  module.exports = Engine;

}).call(this);
