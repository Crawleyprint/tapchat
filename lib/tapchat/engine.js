// Generated by CoffeeScript 1.6.2
(function() {
  var BacklogDB, CoffeeScript, Config, Crypto, Eco, Engine, Express, Fs, Gzippo, Http, Https, LocalStrategy, Log, Passport, PasswordHash, Path, SessionStore, Url, User, Util, WebSocket, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, _, _ref;

  Path = require('path');

  Fs = require('fs');

  WorkingQueue = require('capisce').WorkingQueue;

  Http = require('http');

  Https = require('https');

  Passport = require('passport');

  LocalStrategy = require('passport-local').Strategy;

  Express = require('express');

  Url = require('url');

  WebSocket = require('faye-websocket');

  PasswordHash = require('password-hash');

  CoffeeScript = require('coffee-script');

  Util = require('util');

  Crypto = require('crypto');

  _ = require('underscore');

  Gzippo = require('gzippo');

  Eco = require('eco');

  Log = require('./log');

  Config = require('./config');

  User = require('./user');

  BacklogDB = require('./backlog_db');

  SessionStore = require('./session_store');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  Engine = (function() {
    function Engine(config, initialUser, callback) {
      var _this = this;

      this.users = [];
      this.port = config.port;
      this.db = new BacklogDB(function() {
        if (initialUser) {
          return _this.db.insertUser(initialUser.name, initialUser.password, true, function() {
            return _this.finishLoading(callback);
          });
        } else {
          return _this.finishLoading(callback);
        }
      });
    }

    Engine.prototype.finishLoading = function(callback) {
      var _this = this;

      this.startServer(this.port, callback);
      return this.db.selectUsers(function(users) {
        var userInfo, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = users.length; _i < _len; _i++) {
          userInfo = users[_i];
          _results.push(_this.addUser(userInfo));
        }
        return _results;
      });
    };

    Engine.prototype.startServer = function(port, callback) {
      var restrict, restrict_admin,
        _this = this;

      Passport.use(new LocalStrategy(function(username, password, done) {
        return _this.db.selectUserByName(username, function(userInfo) {
          if (userInfo == null) {
            return done(null, false, {
              message: 'Invalid username'
            });
          }
          if (!PasswordHash.verify(password, userInfo.password)) {
            return done(null, false, {
              message: 'Invalid password'
            });
          }
          return done(null, userInfo);
        });
      }));
      this.sessions = new SessionStore(Path.join(Config.getDataDirectory(), 'sessions.json'));
      this.app = Express();
      if (Log.level === 'silly') {
        this.app.use(Express.logger());
      }
      this.app.use(Express.cookieParser());
      this.app.use(Express.bodyParser());
      this.app.use(Express.methodOverride());
      this.app.use(Passport.initialize());
      this.app.use(Express["static"](__dirname + '/../../web'));
      this.app.use(Gzippo.compress());
      this.app.set('views', __dirname + '/../../web');
      this.app.engine('eco', function(path, options, fn) {
        return Fs.readFile(path, 'utf8', function(err, str) {
          if (err) {
            return fn(err);
          }
          str = Eco.render(str, options);
          return fn(null, str);
        });
      });
      restrict = function(req, res, next) {
        var session;

        session = _this.sessions.get(req.cookies.session);
        if (!session) {
          return res.send(401, 'Unauthorized');
        } else {
          req.session = session;
          req.user = _this.users[session.uid];
          return next();
        }
      };
      restrict_admin = function(req, res, next) {
        var _this = this;

        return restrict(req, res, function() {
          if (!req.user.is_admin) {
            return res.send(401, 'Unauthorized');
          } else {
            return next();
          }
        });
      };
      this.app.get('/', function(req, res) {
        return res.render('index.html');
      });
      this.app.post('/chat/login', function(req, res) {
        var auth;

        if (req.body.email != null) {
          req.body.username = req.body.email;
        }
        if (req.body.username == null) {
          req.body.username = 'user';
        }
        auth = Passport.authenticate('local', function(err, user, info) {
          var response, sessionId;

          if (err) {
            return next(err);
          }
          if (!user) {
            response = {
              success: false,
              message: info.message
            };
            res.json(response, 401);
          }
          if (user) {
            sessionId = Crypto.randomBytes(32).toString('hex');
            _this.sessions.set(sessionId, {
              uid: user.uid
            });
            response = {
              success: true,
              session: sessionId,
              user: {
                id: user.uid,
                name: user.name,
                is_admin: user.is_admin === 1
              }
            };
            return res.json(response);
          }
        });
        return auth(req, res);
      });
      this.app.post('/chat/logout', restrict, function(req, res) {
        _this.sessions.destroy(req.cookies.session);
        return res.json({
          success: true
        });
      });
      this.app.post('/chat/change-password', restrict, function(req, res) {
        var newpassword, oldpassword;

        oldpassword = req.body.oldpassword;
        newpassword = req.body.newpassword;
        if (!((newpassword != null) && newpassword.length >= 8)) {
          res.json({
            success: false,
            message: 'New password is too short.'
          }, 400);
          return;
        }
        return _this.db.selectUser(req.session.uid, function(userInfo) {
          if (!PasswordHash.verify(oldpassword, userInfo.password)) {
            res.json({
              success: false,
              message: 'Incorrect old password.'
            }, 400);
            return;
          }
          return _this.db.updateUser(req.session.uid, {
            password_hash: PasswordHash.generate(newpassword)
          }, function(row) {
            return res.json({
              success: true
            });
          });
        });
      });
      this.app.get('/chat/backlog', restrict, function(req, res) {
        var events, user;

        user = req.user;
        events = [];
        return user.getBacklog((function(event) {
          return events.push(user.prepareMessage(event));
        }), function() {
          return res.json(events);
        });
      });
      this.app.get('/admin/users', restrict_admin, function(req, res) {
        var uid, user, users;

        user = req.user;
        users = (function() {
          var _ref1, _results;

          _ref1 = this.users;
          _results = [];
          for (uid in _ref1) {
            user = _ref1[uid];
            _results.push(user.asJson());
          }
          return _results;
        }).call(_this);
        return res.json(users);
      });
      this.app.post('/admin/users', restrict_admin, function(req, res) {
        var isAdmin, name, password;

        name = req.body.name;
        password = req.body.password;
        isAdmin = req.body.is_admin === 'true';
        return _this.db.insertUser(name, PasswordHash.generate(password), isAdmin, function(row) {
          var user;

          user = _this.addUser(row);
          return res.json({
            success: true,
            user: user.asJson()
          });
        });
      });
      this.app.put('/admin/users/:user_id', restrict_admin, function(req, res) {
        var user;

        user = _this.users[req.param('user_id')];
        return user.edit({
          password_hash: PasswordHash.generate(req.body.password),
          is_admin: req.body.is_admin === 'true' ? 1 : 0
        }, function() {
          return res.json({
            success: true
          });
        });
      });
      this.app["delete"]('/admin/users/:user_id', restrict_admin, function(req, res) {
        var user;

        user = _this.users[req.param('user_id')];
        return _this.deleteUser(user, function() {
          var session, session_id, _ref1;

          _ref1 = _this.sessions.all();
          for (session_id in _ref1) {
            session = _ref1[session_id];
            if (session.uid === user.id) {
              _this.sessions.destroy(session_id);
            }
          }
          return res.json({
            success: true
          });
        });
      });
      this.web = Https.createServer({
        key: Fs.readFileSync(Config.getCertFile()),
        cert: Fs.readFileSync(Config.getCertFile())
      }, this.app);
      this.web.addListener('upgrade', function(req, socket, head) {
        var res;

        req.method = 'UPGRADE';
        res = new Http.ServerResponse(req);
        return _this.app.handle(req, res, function() {
          var session, user, ws;

          session = _this.sessions.get(req.cookies.session);
          if (!session) {
            req.socket.end('HTTP/1.1 401 Unauthorized\r\n\r\n');
            return;
          }
          user = _this.users[session.uid];
          ws = new WebSocket(req, socket, head);
          return user.addClient(ws, req.param('inband', false));
        });
      });
      return this.web.listen(port, '::', function() {
        console.log("\nTapChat ready at https://localhost:" + port + "\n");
        if (callback) {
          return callback(_this);
        }
      });
    };

    Engine.prototype.addUser = function(userInfo) {
      var user;

      user = new User(this, userInfo);
      return this.users[user.id] = user;
    };

    Engine.prototype.deleteUser = function(user, cb) {
      var _this = this;

      return user["delete"](function() {
        _this.users.splice(_this.users.indexOf(user), 1);
        if (cb) {
          return cb();
        }
      });
    };

    return Engine;

  })();

  module.exports = Engine;

}).call(this);
