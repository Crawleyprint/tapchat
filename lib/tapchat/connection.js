// Generated by CoffeeScript 1.3.3
(function() {
  var B, Buffer, CoffeeScript, Connection, EventEmitter, Irc, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, util, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Irc = require('../irc/irc');

  EventEmitter = require('events').EventEmitter;

  WorkingQueue = require('capisce').WorkingQueue;

  util = require('util');

  _ = require('underscore');

  CoffeeScript = require('coffee-script');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  Buffer = require('./buffer');

  B = require('./message_builder');

  Connection = (function(_super) {

    __extends(Connection, _super);

    function Connection(engine, options, callback) {
      this.addBuffer = __bind(this.addBuffer, this);

      var _this = this;
      this.engine = engine;
      this.buffers = [];
      this.queue = new WorkingQueue(1);
      this.id = options.cid;
      this.name = options.name;
      this.autoConnect = !!options.auto_connect;
      this.client = new Irc.Client(options.server, options.nick, {
        name: options.name,
        server: options.server,
        port: options.port,
        secure: !!options.is_ssl,
        userName: options.user_name,
        realName: options.real_name,
        password: options.server_pass,
        autoConnect: false,
        debug: true
      });
      this.addEventListeners();
      this.engine.db.selectBuffers(this.id, function(buffers) {
        var buffer, bufferInfo, _i, _len;
        for (_i = 0, _len = buffers.length; _i < _len; _i++) {
          bufferInfo = buffers[_i];
          buffer = _this.addBuffer(bufferInfo);
          if (buffer.type === 'console') {
            _this.consoleBuffer = buffer;
          }
        }
        if (!_this.consoleBuffer) {
          return _this.createBuffer('*', 'console', function(buffer) {
            _this.consoleBuffer = buffer;
            return callback(_this);
          });
        } else {
          return callback(_this);
        }
      });
    }

    Connection.prototype.connect = function() {
      return this.client.connect();
    };

    Connection.prototype.disconnect = function(cb) {
      if (this.client) {
        return this.client.disconnect(cb);
      } else {
        if (cb) {
          return cb();
        }
      }
    };

    Connection.prototype.reconnect = function(callback) {
      var _this = this;
      return this.disconnect(function() {
        _this.connect();
        if (callback) {
          return callback();
        }
      });
    };

    Connection.prototype["delete"] = function(cb) {
      var _this = this;
      return this.disconnect(function() {
        var buffer, _i, _len, _ref1;
        _ref1 = _this.buffers;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          buffer.removeAllListeners();
        }
        _this.client.removeAllListeners();
        _this.client = null;
        return _this.engine.db.deleteConnection(_this.id, function() {
          if (cb) {
            return cb();
          }
        });
      });
    };

    Connection.prototype.setNick = function(nick) {
      return this.client.send("NICK " + nick);
    };

    Connection.prototype.say = function(to, text) {
      return this.client.say(to, text);
    };

    Connection.prototype.join = function(chan) {
      return this.client.join(chan);
    };

    Connection.prototype.part = function(chan) {
      return this.client.part(chan);
    };

    Connection.prototype.addBuffer = function(bufferInfo) {
      var buffer,
        _this = this;
      buffer = new Buffer(this, bufferInfo);
      this.buffers.push(buffer);
      buffer.on('event', function(event) {
        return _this.emit('event', event);
      });
      this.emit('event', B.makeBuffer(buffer));
      return buffer;
    };

    Connection.prototype.removeBuffer = function(buffer) {
      buffer.removeAllListeners();
      this.buffers.splice(this.buffers.indexOf(buffer), 1);
      return this.emit('event', B.deleteBuffer(buffer));
    };

    Connection.prototype.sendBacklog = function(client, callback) {
      var buffer, bufferQueue, queue, send, _fn, _i, _len, _ref1,
        _this = this;
      queue = new WorkingQueue(1);
      send = function(message) {
        return queue.perform(function(over) {
          if (client) {
            return _this.engine.send(client, message, over);
          } else {
            return _this.engine.broadcast(message, over);
          }
        });
      };
      send(B.makeServer(this));
      bufferQueue = new WorkingQueue(1);
      _ref1 = this.buffers;
      _fn = function(buffer) {
        return bufferQueue.perform(function(bufferOver) {
          send(B.makeBuffer(buffer));
          if (buffer.type === 'channel' && buffer.isJoined) {
            send(B.channelInit(buffer));
          }
          return buffer.getBacklog(function(events) {
            var event, _j, _len1;
            for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
              event = events[_j];
              send(event);
            }
            return bufferOver();
          });
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        _fn(buffer);
      }
      bufferQueue.whenDone(function() {
        var _j, _len1, _ref2;
        if (client) {
          send({
            type: 'end_of_backlog',
            cid: _this.id
          });
        }
        if (_this.isConnecting()) {
          _ref2 = _this.buffers;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            buffer = _ref2[_j];
            send(merge(B.connecting(_this), {
              bid: buffer.id
            }));
          }
        }
        return queue.doneAddingJobs();
      });
      bufferQueue.doneAddingJobs();
      return queue.whenDone(function() {
        return callback();
      });
    };

    Connection.prototype.edit = function(options, callback) {
      var _this = this;
      return this.engine.db.updateConnection(this.id, options, function(row) {
        _this.updateAttributes(row);
        _this.engine.broadcast(B.serverDetailsChanged(_this));
        return callback(row);
      });
    };

    Connection.prototype.updateAttributes = function(options) {
      var nickChanged, serverChanged;
      serverChanged = (this.getHostName() && (this.getHostName() !== options.server || this.getPort() !== options.port)) || (this.isSSL() !== (!!options.ssl)) || (this.getServerPass() !== options.server_pass);
      nickChanged = this.getNick() && (this.getNick() !== options.nick);
      this.name = options.name;
      this.client.opt.server = options.server;
      this.client.opt.port = options.port;
      this.client.opt.secure = !!options.is_ssl;
      this.client.opt.nick = options.nick;
      this.client.opt.userName = options.user_name;
      this.client.opt.realName = options.real_name;
      this.client.opt.password = options.server_pass;
      if (serverChanged) {
        return this.reconnect();
      } else {
        if (nickChanged) {
          return this.setNick(this.client.opt.nick);
        }
      }
    };

    Connection.prototype.addEventToAllBuffers = function(event, callback) {
      var buffer, queue, _fn, _i, _len, _ref1,
        _this = this;
      queue = new WorkingQueue(1);
      queue.whenDone(function() {
        return callback();
      });
      _ref1 = this.buffers;
      _fn = function(buffer) {
        return queue.perform(function(over) {
          return buffer.addEvent(event, over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        _fn(buffer);
      }
      return queue.doneAddingJobs();
    };

    Connection.prototype.getName = function() {
      return this.name;
    };

    Connection.prototype.getConfiguredNick = function() {
      return this.client.opt.nick;
    };

    Connection.prototype.getNick = function() {
      return this.client.nick;
    };

    Connection.prototype.getRealName = function() {
      return this.client.opt.realName;
    };

    Connection.prototype.getHostName = function() {
      return this.client.opt.server;
    };

    Connection.prototype.getPort = function() {
      return this.client.opt.port;
    };

    Connection.prototype.isDisconnected = function() {
      return this.client.conn === null || this.client.conn.readyState !== 'open';
    };

    Connection.prototype.isConnecting = function() {
      return this.client.conn !== null && this.client.conn.readyState === 'opening';
    };

    Connection.prototype.isSSL = function() {
      return this.client.opt.secure;
    };

    Connection.prototype.getServerPass = function() {
      return this.client.opt.password;
    };

    Connection.prototype.findBuffer = function(bid) {
      var buffer, _i, _len, _ref1;
      _ref1 = this.buffers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        if (buffer.id === bid) {
          return buffer;
        }
      }
      return null;
    };

    Connection.prototype.getBuffer = function(name) {
      var buffer, _i, _len, _ref1;
      _ref1 = this.buffers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        if (buffer.name === name) {
          return buffer;
        }
      }
      return null;
    };

    Connection.prototype.getOrCreateBuffer = function(name, type, callback) {
      var buffer;
      if (!name) {
        throw 'missing name';
      }
      if (!type) {
        throw 'missing type';
      }
      buffer = this.getBuffer(name);
      if (buffer) {
        return callback(buffer, false);
      }
      return this.createBuffer(name, type, callback);
    };

    Connection.prototype.createBuffer = function(name, type, callback) {
      var self,
        _this = this;
      self = this;
      return this.engine.db.insertBuffer(this.id, name, type, function(bufferInfo) {
        var buffer;
        buffer = self.addBuffer(bufferInfo);
        return callback(buffer, true);
      });
    };

    Connection.prototype.addEventListeners = function() {
      var signalHandler, signalName, _ref1, _results,
        _this = this;
      _ref1 = this.signalHandlers;
      _results = [];
      for (signalName in _ref1) {
        signalHandler = _ref1[signalName];
        _results.push((function(signalName, signalHandler) {
          return _this.client.addListener(signalName, function() {
            var args, handler;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            handler = function() {
              var whitelist;
              whitelist = ['connecting', 'close', 'abort', 'netError', 'error', 'raw'];
              if (_this.isDisconnected() && (!_.include(whitelist, signalName))) {
                console.log('Disconnected before event handler ran!', _this.id, _this.name, signalName);
                return _.last(arguments)();
              }
              return signalHandler.apply(_this, arguments);
            };
            return _this.queue.perform(function(over) {
              var overWrapper,
                _this = this;
              overWrapper = function() {
                return over();
              };
              args.push(overWrapper);
              return handler.apply(null, args);
            });
          });
        })(signalName, signalHandler));
      }
      return _results;
    };

    Connection.prototype.shouldHighlight = function(message) {
      return !!message.match(this.getNick());
    };

    Connection.prototype.signalHandlers = {
      connecting: function(over) {
        return this.addEventToAllBuffers(B.connecting(this), over);
      },
      connect: function(over) {
        return this.addEventToAllBuffers({
          type: 'connected',
          ssl: this.isSSL(),
          hostname: this.getHostName(),
          port: this.getPort()
        }, over);
      },
      close: function(over) {
        var buffer, _i, _len, _ref1;
        _ref1 = this.buffers;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          if (buffer.type === 'channel') {
            buffer.setJoined(false);
          }
        }
        return this.addEventToAllBuffers({
          type: 'socket_closed'
        }, over);
      },
      abort: function(retryCount, over) {
        return this.addEventToAllBuffers({
          type: 'connecting_failed',
          hostname: this.getHostName(),
          port: this.getPort()
        }, over);
      },
      registered: function(message, over) {
        var buffer, _i, _len, _ref1, _results;
        this.addEventToAllBuffers({
          type: 'connecting_finished'
        }, over);
        _ref1 = this.buffers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          if (buffer.type === 'channel' && (!buffer.isArchived) && buffer.autoJoin) {
            _results.push(this.client.join(buffer.name));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      motd: function(motd, over) {
        return this.consoleBuffer.addEvent(B.serverMotd(this, motd), over);
      },
      names: function(channel, nicks, over) {
        var buffer;
        if (buffer = this.getBuffer(channel)) {
          buffer.setMembers(_.keys(nicks));
          this.emit('event', B.channelInit(buffer));
          return over();
        }
      },
      topic: function(channel, topic, nick, message, over) {
        var buffer;
        if (buffer = this.getBuffer(channel)) {
          buffer.topicText = topic;
          buffer.topicBy = nick;
          buffer.topicTime = null;
          if (!_.isEmpty(nick)) {
            buffer.addEvent({
              type: 'channel_topic',
              author: nick,
              topic: topic
            }, over);
            return;
          }
        }
        return over();
      },
      join: function(channel, nick, message, over) {
        var buffer;
        if (nick === this.getNick()) {
          return this.signalHandlers.selfJoin.apply(this, [channel, message, over]);
        }
        if (buffer = this.getBuffer(channel)) {
          buffer.addMember(nick);
          return buffer.addEvent({
            type: 'joined_channel',
            nick: nick
          }, over);
        } else {
          return over();
        }
      },
      selfJoin: function(channel, message, over) {
        var _this = this;
        return this.getOrCreateBuffer(channel, Buffer.prototype.TYPE_CHANNEL, function(buffer) {
          buffer.addMember(_this.getNick());
          buffer.setJoined(true);
          return buffer.addEvent({
            type: 'you_joined_channel'
          }, over);
        });
      },
      part: function(channel, nick, reason, message, over) {
        var buffer;
        if (nick === this.getNick()) {
          return this.signalHandlers.selfPart.apply(this, [channel, reason, over]);
        }
        if (buffer = this.getBuffer(channel)) {
          buffer.removeMember(nick);
          buffer.isJoined = false;
          return buffer.addEvent({
            type: 'parted_channel',
            nick: nick
          }, over);
        } else {
          return over();
        }
      },
      selfPart: function(channel, reason, over) {
        var buffer;
        if (buffer = this.getBuffer(channel)) {
          buffer.setJoined(false);
          return buffer.addEvent({
            type: 'you_parted_channel'
          }, over);
        } else {
          return over();
        }
      },
      kick: function(channel, nick, byNick, reason, message, over) {
        var buffer;
        if (buffer = this.getBuffer(channel)) {
          buffer.removeMember(nick);
          return buffer.addEvent({
            type: 'kicked_channel',
            nick: nick,
            kicker: byNick,
            msg: reason
          }, over);
        } else {
          return over();
        }
      },
      selfQuit: function(reason, over) {
        var buffer, _i, _len, _ref1;
        _ref1 = this.buffers;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          if (buffer.type === 'channel') {
            buffer.setJoined(false);
          }
        }
        return this.addEventToAllBuffers({
          type: 'quit_server',
          msg: reason
        }, over);
      },
      quit: function(nick, reason, channels, message, over) {
        var name, queue, _fn, _i, _len, _ref1,
          _this = this;
        queue = new WorkingQueue(1);
        _ref1 = [nick].concat(channels);
        _fn = function(name) {
          return queue.perform(function(bufferOver) {
            var buffer;
            if (buffer = _this.getBuffer(name)) {
              buffer.removeMember(nick);
              return buffer.addEvent({
                type: 'quit',
                nick: nick,
                msg: reason
              }, function() {
                return bufferOver();
              });
            } else {
              return bufferOver();
            }
          });
        };
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          name = _ref1[_i];
          _fn(name);
        }
        queue.whenDone(function() {
          return over();
        });
        return queue.doneAddingJobs();
      },
      kill: function(nick, reason, channels, message, over) {
        var buffer, name, _i, _len, _ref1, _results;
        _ref1 = [nick].concat(channels);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          name = _ref1[_i];
          if (buffer = this.getBuffer(name)) {
            buffer.removeMember(nick);
            _results.push(buffer.addEvent({
              type: 'kill',
              from: nick,
              reason: message
            }, over));
          } else {
            _results.push(over());
          }
        }
        return _results;
      },
      selfMessage: function(to, text, over) {
        var buffer,
          _this = this;
        if (to.match(/^[&#]/)) {
          if (buffer = this.getBuffer(to)) {
            return buffer.addEvent({
              type: 'buffer_msg',
              from: this.getNick(),
              chan: to,
              msg: text,
              highlight: false,
              self: true
            }, over);
          } else {
            return over();
          }
        } else {
          return this.getOrCreateBuffer(to, Buffer.prototype.TYPE_QUERY, function(buffer) {
            return buffer.addEvent({
              type: 'buffer_msg',
              from: _this.getNick(),
              msg: text,
              highlight: false,
              self: true
            }, over);
          });
        }
      },
      message: function(nick, to, text, message, over) {
        var buffer, bufferName, highlight,
          _this = this;
        if (to.match(/^[&#]/)) {
          if (buffer = this.getBuffer(to)) {
            highlight = this.shouldHighlight(text);
            return buffer.addEvent({
              type: 'buffer_msg',
              from: nick,
              chan: to,
              msg: text,
              highlight: highlight,
              self: false
            }, over);
          } else {
            return over();
          }
        } else {
          bufferName = nick === this.getNick() ? to : nick;
          return this.getOrCreateBuffer(bufferName, Buffer.prototype.TYPE_QUERY, function(buffer) {
            return buffer.addEvent({
              type: 'buffer_msg',
              from: nick,
              msg: text,
              highlight: true,
              self: false
            }, over);
          });
        }
      },
      action: function(from, to, text, over) {
        var buffer, bufferName, isChannel;
        isChannel = to.match(/^[&#]/);
        bufferName = isChannel ? to : from;
        buffer = this.getBuffer(bufferName);
        if (buffer) {
          return buffer.addEvent({
            type: 'buffer_me_msg',
            from: from,
            msg: text
          }, over);
        } else {
          return over();
        }
      },
      notice: function(nick, to, text, message, over) {
        var buffer;
        buffer = !nick || !to ? this.consoleBuffer : this.getBuffer(to);
        if (buffer) {
          return buffer.addEvent({
            type: 'notice',
            msg: text
          }, over);
        } else {
          return over();
        }
      },
      nick: function(oldnick, newnick, channels, message, over) {
        var buffer, name, queue, _i, _len, _ref1,
          _this = this;
        queue = new WorkingQueue(1);
        _ref1 = [oldnick].concat(channels);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          name = _ref1[_i];
          if (buffer = this.getBuffer(name)) {
            queue.perform(function(addEventOver) {
              return buffer.addEvent({
                type: 'nickchange',
                newnick: newnick,
                oldnick: oldnick
              }, addEventOver);
            });
          }
        }
        queue.whenDone(function() {
          return over();
        });
        return queue.doneAddingJobs();
      },
      selfNick: function(oldnick, newnick, channels, message, over) {
        var buffer, name, queue, _i, _len, _ref1,
          _this = this;
        queue = new WorkingQueue(1);
        queue.perform(function(addEventOver) {
          return _this.consoleBuffer.addEvent({
            type: 'you_nickchange',
            newnick: newnick,
            oldnick: oldnick
          }, addEventOver);
        });
        _ref1 = [oldnick].concat(channels);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          name = _ref1[_i];
          if (buffer = this.getBuffer(name)) {
            queue.perform(function(addEventOver) {
              return buffer.addEvent({
                type: 'you_nickchange',
                newnick: newnick,
                oldnick: oldnick
              }, addEventOver);
            });
          }
        }
        queue.whenDone(function() {
          return over();
        });
        return queue.doneAddingJobs();
      },
      invite: function(channel, from, message, over) {
        return this.consoleBuffer.addEvent({
          type: 'channel_invite',
          channel: channel,
          from: from
        }, over);
      },
      raw: function(message, over) {
        console.log("IRC RECV: " + (this.getName()) + " " + (JSON.stringify(message)));
        return over();
      },
      netError: function(ex, over) {
        var _this = this;
        console.log('Net error: ', ex);
        return this.consoleBuffer.addEvent({
          type: 'error',
          msg: ex
        }, function() {
          _this.disconnect();
          return over();
        });
      },
      error: function(error, over) {
        var _this = this;
        console.log('Error: ', error);
        return this.consoleBuffer.addEvent({
          type: 'error',
          msg: error.args.join(' ')
        }, function() {
          _this.disconnect();
          return over();
        });
      }
    };

    return Connection;

  })(EventEmitter);

  module.exports = Connection;

}).call(this);
