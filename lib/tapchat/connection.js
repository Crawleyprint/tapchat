// Generated by CoffeeScript 1.6.2
(function() {
  var B, ChannelBuffer, CoffeeScript, Connection, ConsoleBuffer, ConversationBuffer, EventEmitter, Irc, Log, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, util, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  Irc = require('../irc/irc');

  EventEmitter = require('events').EventEmitter;

  WorkingQueue = require('capisce').WorkingQueue;

  util = require('util');

  _ = require('underscore');

  CoffeeScript = require('coffee-script');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  Log = require('./log');

  ConsoleBuffer = require('./console_buffer');

  ChannelBuffer = require('./channel_buffer');

  ConversationBuffer = require('./conversation_buffer');

  B = require('./message_builder');

  Connection = (function(_super) {
    __extends(Connection, _super);

    function Connection(user, engine, options, callback) {
      this.addBuffer = __bind(this.addBuffer, this);
      var _this = this;

      this.user = user;
      this.engine = engine;
      this.buffers = [];
      this.queue = new WorkingQueue(1);
      this.id = options.cid;
      this.name = options.name;
      this.autoConnect = !!options.auto_connect;
      this.sslFingerprint = options.ssl_fingerprint;
      this.client = new Irc.Client(options.server, options.nick, {
        name: options.name,
        server: options.server,
        port: options.port,
        secure: !!options.is_ssl,
        userName: options.user_name,
        realName: options.real_name,
        password: options.server_pass,
        autoConnect: false
      });
      this.addEventListeners();
      this.engine.db.selectBuffers(this.id, function(buffers) {
        var buffer, bufferInfo, _i, _len;

        for (_i = 0, _len = buffers.length; _i < _len; _i++) {
          bufferInfo = buffers[_i];
          buffer = _this.addBuffer(bufferInfo);
          if (buffer instanceof ConsoleBuffer) {
            _this.consoleBuffer = buffer;
          }
        }
        if (!_this.consoleBuffer) {
          return _this.createBuffer('*', 'console', function(buffer) {
            _this.consoleBuffer = buffer;
            return callback(_this);
          });
        } else {
          return callback(_this);
        }
      });
    }

    Connection.prototype.connect = function() {
      return this.client.connect();
    };

    Connection.prototype.disconnect = function(cb) {
      if (this.client) {
        return this.client.disconnect(cb);
      } else {
        if (cb) {
          return cb();
        }
      }
    };

    Connection.prototype.reconnect = function(callback) {
      var _this = this;

      return this.disconnect(function() {
        _this.connect();
        if (callback) {
          return callback();
        }
      });
    };

    Connection.prototype["delete"] = function(cb) {
      var _this = this;

      return this.disconnect(function() {
        var buffer, _i, _len, _ref1;

        _ref1 = _this.buffers;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          buffer.removeAllListeners();
        }
        _this.client.removeAllListeners();
        _this.client = null;
        return _this.engine.db.deleteConnection(_this.id, function() {
          if (cb) {
            return cb();
          }
        });
      });
    };

    Connection.prototype.setNick = function(nick) {
      return this.client.send("NICK " + nick);
    };

    Connection.prototype.say = function(to, text) {
      return this.client.say(to, text);
    };

    Connection.prototype.action = function(to, text) {
      return this.client.action(to, text);
    };

    Connection.prototype.join = function(chan) {
      return this.client.join(chan);
    };

    Connection.prototype.part = function(chan) {
      return this.client.part(chan);
    };

    Connection.prototype.addBuffer = function(bufferInfo) {
      var buffer,
        _this = this;

      if (bufferInfo.type === 'console') {
        buffer = new ConsoleBuffer(this, bufferInfo);
      } else if (bufferInfo.type === 'channel') {
        buffer = new ChannelBuffer(this, bufferInfo);
      } else if (bufferInfo.type === 'conversation') {
        buffer = new ConversationBuffer(this, bufferInfo);
      } else {
        throw "Unknown buffer type: " + bufferInfo.type;
      }
      this.buffers.push(buffer);
      buffer.on('event', function(event) {
        return _this.emit('event', event);
      });
      this.emit('event', B.makeBuffer(buffer));
      return buffer;
    };

    Connection.prototype.removeBuffer = function(buffer) {
      buffer.removeAllListeners();
      this.buffers.splice(this.buffers.indexOf(buffer), 1);
      return this.emit('event', B.deleteBuffer(buffer));
    };

    Connection.prototype.sendBacklog = function(client, callback) {
      var queue, send,
        _this = this;

      queue = new WorkingQueue(1);
      send = function(message) {
        return queue.perform(function(over) {
          if (client) {
            return _this.user.send(client, message, over);
          } else {
            return _this.user.broadcast(message, over);
          }
        });
      };
      return this.getBacklog((function(event) {
        if (event.type !== 'end_of_backlog' || (event.type === 'end_of_backlog' && !client)) {
          return send(event);
        }
      }), function() {
        queue.onceDone(callback);
        return queue.doneAddingJobs();
      });
    };

    Connection.prototype.getBacklog = function(callback, done) {
      var buffer, queue, _fn, _i, _len, _ref1,
        _this = this;

      callback(B.makeServer(this));
      queue = new WorkingQueue(1);
      _ref1 = this.buffers;
      _fn = function(buffer) {
        return queue.perform(function(bufferOver) {
          callback(B.makeBuffer(buffer));
          if (buffer instanceof ChannelBuffer && buffer.isJoined) {
            callback(B.channelInit(buffer));
          }
          return buffer.getBacklog(function(events) {
            var event, _j, _len1;

            for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
              event = events[_j];
              callback(event);
            }
            return bufferOver();
          });
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        _fn(buffer);
      }
      queue.onceDone(function() {
        var _j, _len1, _ref2, _results;

        callback({
          type: 'end_of_backlog',
          cid: _this.id
        });
        if (_this.isConnecting()) {
          _ref2 = _this.buffers;
          _results = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            buffer = _ref2[_j];
            _results.push(callback(merge(B.connecting(_this), {
              bid: buffer.id
            })));
          }
          return _results;
        }
      });
      queue.onceDone(done);
      return queue.doneAddingJobs();
    };

    Connection.prototype.edit = function(options, callback) {
      var _this = this;

      return this.engine.db.updateConnection(this.id, options, function(row) {
        _this.updateAttributes(row);
        _this.user.broadcast(B.serverDetailsChanged(_this));
        return callback(row);
      });
    };

    Connection.prototype.acceptCert = function(fingerprint, accept, done) {
      var callback, fingerpint, options,
        _this = this;

      if ((!this.pendingSSLCallback) || this.pendingSSLFingerprint !== fingerprint) {
        done();
        return;
      }
      fingerpint = this.pendingSSLFingerprint;
      callback = this.pendingSSLCallback;
      this.pendingSSLFingerprint = null;
      this.pendingSSLCallback = null;
      if (!accept) {
        callback(false);
        done();
        return;
      }
      options = {
        ssl_fingerprint: fingerprint
      };
      return this.engine.db.updateConnection(this.id, options, function(row) {
        _this.sslFingerprint = fingerprint;
        callback(true);
        return done();
      });
    };

    Connection.prototype.updateAttributes = function(options) {
      var nickChanged, serverChanged;

      serverChanged = (this.getHostName() && (this.getHostName() !== options.server || this.getPort() !== options.port)) || (this.isSSL() !== (!!options.ssl)) || (this.getServerPass() !== options.server_pass);
      nickChanged = this.getNick() && (this.getNick() !== options.nick);
      this.name = options.name;
      this.client.opt.server = options.server;
      this.client.opt.port = options.port;
      this.client.opt.secure = !!options.is_ssl;
      this.client.opt.nick = options.nick;
      this.client.opt.userName = options.user_name;
      this.client.opt.realName = options.real_name;
      this.client.opt.password = options.server_pass;
      if (serverChanged) {
        return this.reconnect();
      } else {
        if (nickChanged) {
          return this.setNick(this.client.opt.nick);
        }
      }
    };

    Connection.prototype.addEventToAllBuffers = function(event, callback) {
      var buffer, queue, _i, _len, _ref1,
        _this = this;

      queue = new WorkingQueue(1);
      queue.onceDone(callback);
      _ref1 = this.buffers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        if (buffer.getIsActive()) {
          (function(buffer) {
            return queue.perform(function(over) {
              return buffer.addEvent(event, over);
            });
          })(buffer);
        }
      }
      return queue.doneAddingJobs();
    };

    Connection.prototype.getName = function() {
      return this.name;
    };

    Connection.prototype.getConfiguredNick = function() {
      return this.client.opt.nick;
    };

    Connection.prototype.getNick = function() {
      return this.client.nick;
    };

    Connection.prototype.getRealName = function() {
      return this.client.opt.realName;
    };

    Connection.prototype.getHostName = function() {
      return this.client.opt.server;
    };

    Connection.prototype.getPort = function() {
      return this.client.opt.port;
    };

    Connection.prototype.isDisconnected = function() {
      return this.client.conn === null || this.client.conn.readyState !== 'open';
    };

    Connection.prototype.isConnecting = function() {
      return (this.client.conn !== null) && ((this.client.conn.readyState === 'opening') || (this.client.conn.readyState === 'open' && (!this.isRegistered)));
    };

    Connection.prototype.isSSL = function() {
      return this.client.opt.secure;
    };

    Connection.prototype.getServerPass = function() {
      return this.client.opt.password;
    };

    Connection.prototype.findBuffer = function(bid) {
      var buffer, _i, _len, _ref1;

      _ref1 = this.buffers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        if (buffer.id === bid) {
          return buffer;
        }
      }
      return null;
    };

    Connection.prototype.buffersForMember = function(nick) {
      return this.buffers.filter(function(buffer) {
        return (buffer instanceof ChannelBuffer && buffer.getMember(nick)) || (buffer.name === nick);
      });
    };

    Connection.prototype.getBuffer = function(name) {
      var buffer, _i, _len, _ref1;

      if (!name) {
        return null;
      }
      _ref1 = this.buffers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        buffer = _ref1[_i];
        if (buffer.name.toLowerCase() === name.toLowerCase()) {
          return buffer;
        }
      }
      return null;
    };

    Connection.prototype.getOrCreateBuffer = function(name, type, callback) {
      var buffer, expectedType;

      if (!name) {
        throw 'missing name';
      }
      if (!type) {
        throw 'missing type';
      }
      expectedType = (function() {
        switch (type) {
          case 'console':
            return ConsoleBuffer;
          case 'channel':
            return ChannelBuffer;
          case 'conversation':
            return ConversationBuffer;
          default:
            return null;
        }
      })();
      buffer = this.getBuffer(name);
      if (buffer && buffer instanceof expectedType) {
        return callback(buffer, false);
      }
      return this.createBuffer(name, type, callback);
    };

    Connection.prototype.createBuffer = function(name, type, callback) {
      var self,
        _this = this;

      self = this;
      return this.engine.db.insertBuffer(this.id, this.user.id, name, type, function(bufferInfo) {
        var buffer;

        buffer = self.addBuffer(bufferInfo);
        return callback(buffer, true);
      });
    };

    Connection.prototype.addEventListeners = function() {
      var signalHandler, signalName, _ref1, _results,
        _this = this;

      _ref1 = this.signalHandlers;
      _results = [];
      for (signalName in _ref1) {
        signalHandler = _ref1[signalName];
        _results.push((function(signalName, signalHandler) {
          return _this.client.addListener(signalName, function() {
            var args, handler;

            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            handler = function() {
              var whitelist;

              whitelist = ['connecting', 'close', 'abort', 'verifyCert', 'netError', 'error', 'recvLine'];
              if (_this.isDisconnected() && (!_.include(whitelist, signalName))) {
                Log.warn('Disconnected before event handler ran!', {
                  connId: _this.id,
                  connName: _this.name,
                  signal: signalName
                });
                return _.last(arguments)();
              }
              return signalHandler.apply(_this, arguments);
            };
            return _this.queue.perform(function(over) {
              var overWrapper,
                _this = this;

              overWrapper = function() {
                return over();
              };
              args.push(overWrapper);
              return handler.apply(null, args);
            });
          });
        })(signalName, signalHandler));
      }
      return _results;
    };

    Connection.prototype.shouldHighlight = function(message) {
      return message && (message.indexOf(this.getNick()) >= 0);
    };

    Connection.prototype.signalHandlers = {
      connecting: function(over) {
        return this.addEventToAllBuffers(B.connecting(this), over);
      },
      connect: function(over) {
        return this.addEventToAllBuffers({
          type: 'connected',
          ssl: this.isSSL(),
          hostname: this.getHostName(),
          port: this.getPort()
        }, over);
      },
      close: function(over) {
        var queue,
          _this = this;

        this.certCallbacks = {};
        this.isRegistered = false;
        queue = new WorkingQueue(1);
        queue.perform(function(queueOver) {
          return _this.addEventToAllBuffers({
            type: 'socket_closed'
          }, queueOver);
        });
        queue.onceDone(function() {
          var buffer, _i, _len, _ref1;

          _ref1 = _this.buffers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            buffer = _ref1[_i];
            if (buffer instanceof ChannelBuffer) {
              buffer.isJoined = false;
            }
          }
          return over();
        });
        return queue.doneAddingJobs();
      },
      abort: function(retryCount, over) {
        return this.addEventToAllBuffers({
          type: 'connecting_failed',
          hostname: this.getHostName(),
          port: this.getPort()
        }, over);
      },
      registered: function(message, over) {
        var buffer, _i, _len, _ref1, _results;

        this.isRegistered = true;
        this.addEventToAllBuffers({
          type: 'connecting_finished'
        }, over);
        _ref1 = this.buffers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          if (buffer instanceof ChannelBuffer && (!buffer.isArchived) && buffer.autoJoin) {
            _results.push(this.client.join(buffer.name));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      },
      motd: function(motd, over) {
        return this.consoleBuffer.addEvent(B.serverMotd(this, motd), over);
      },
      names: function(channel, nicks, raw, over) {
        var buffer, mode, nick;

        if (buffer = this.getBuffer(channel)) {
          for (nick in nicks) {
            mode = nicks[nick];
            buffer.addMember(nick, mode);
          }
        }
        return over();
      },
      end_of_names: function(channel, raw, over) {
        var buffer;

        if (buffer = this.getBuffer(channel)) {
          this.emit('event', B.channelInit(buffer));
        }
        return over();
      },
      '+mode': function(channel, from, mode, to, raw, over) {
        var buffer, member;

        if (!(buffer = this.getBuffer(channel))) {
          return over();
        }
        if (!(member = buffer.getMember(to))) {
          return over();
        }
        member.addMode(mode);
        return buffer.addEvent({
          type: 'user_channel_mode',
          from: from,
          nick: to,
          newmode: member.mode,
          diff: "+" + mode,
          channel: channel,
          ops: {
            add: [
              {
                mode: mode,
                param: to
              }
            ],
            remove: []
          }
        }, over);
      },
      '-mode': function(channel, from, mode, to, raw, over) {
        var buffer, member;

        if (!(buffer = this.getBuffer(channel))) {
          return over();
        }
        if (!(member = buffer.getMember(to))) {
          return over();
        }
        member.delMode(mode);
        return buffer.addEvent({
          type: 'user_channel_mode',
          from: from,
          nick: to,
          newmode: member.mode,
          diff: "-" + mode,
          channel: channel,
          ops: {
            add: [],
            remove: [
              {
                mode: mode,
                param: to
              }
            ]
          }
        }, over);
      },
      topic: function(channel, topic, nick, message, over) {
        var buffer;

        if (buffer = this.getBuffer(channel)) {
          buffer.topicText = topic;
          buffer.topicBy = nick;
          buffer.topicTime = null;
          if (!_.isEmpty(nick)) {
            buffer.addEvent({
              type: 'channel_topic',
              author: nick,
              topic: topic
            }, over);
            return;
          }
        }
        return over();
      },
      join: function(channel, nick, message, over) {
        var buffer;

        if (nick === this.getNick()) {
          return this.signalHandlers.selfJoin.apply(this, [channel, message, over]);
        }
        if (buffer = this.getBuffer(channel)) {
          buffer.addMember(nick);
          return buffer.addEvent({
            type: 'joined_channel',
            nick: nick
          }, over);
        } else {
          return over();
        }
      },
      selfJoin: function(channel, message, over) {
        var _this = this;

        return this.getOrCreateBuffer(channel, 'channel', function(buffer) {
          buffer.addMember(_this.getNick());
          return buffer.setJoined(true, function() {
            return buffer.addEvent({
              type: 'you_joined_channel'
            }, over);
          });
        });
      },
      part: function(channel, nick, reason, message, over) {
        var buffer;

        if (nick === this.getNick()) {
          return this.signalHandlers.selfPart.apply(this, [channel, reason, over]);
        }
        if (buffer = this.getBuffer(channel)) {
          buffer.removeMember(nick);
          return buffer.addEvent({
            type: 'parted_channel',
            nick: nick
          }, over);
        } else {
          return over();
        }
      },
      selfPart: function(channel, reason, over) {
        var buffer,
          _this = this;

        if (buffer = this.getBuffer(channel)) {
          return buffer.setJoined(false, function() {
            return buffer.addEvent({
              type: 'you_parted_channel'
            }, over);
          });
        } else {
          return over();
        }
      },
      kick: function(channel, nick, byNick, reason, message, over) {
        var buffer;

        if (buffer = this.getBuffer(channel)) {
          buffer.removeMember(nick);
          return buffer.addEvent({
            type: 'kicked_channel',
            nick: nick,
            kicker: byNick,
            msg: reason
          }, over);
        } else {
          return over();
        }
      },
      selfQuit: function(reason, over) {
        var queue,
          _this = this;

        queue = new WorkingQueue(1);
        queue.perform(function(queueOver) {
          return _this.addEventToAllBuffers({
            type: 'quit_server',
            msg: reason
          }, queueOver);
        });
        queue.onceDone(function() {
          var buffer, _i, _len, _ref1;

          _ref1 = _this.buffers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            buffer = _ref1[_i];
            if (buffer instanceof ChannelBuffer) {
              buffer.isJoined = false;
            }
          }
          return over();
        });
        return queue.doneAddingJobs();
      },
      quit: function(nick, reason, message, over) {
        var buffer, queue, _fn, _i, _len, _ref1,
          _this = this;

        queue = new WorkingQueue(1);
        _ref1 = this.buffersForMember(nick);
        _fn = function(buffer) {
          return queue.perform(function(bufferOver) {
            if (buffer instanceof ChannelBuffer) {
              buffer.removeMember(nick);
            }
            return buffer.addEvent({
              type: 'quit',
              nick: nick,
              msg: reason
            }, function() {
              return bufferOver();
            });
          });
        };
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          _fn(buffer);
        }
        queue.onceDone(over);
        return queue.doneAddingJobs();
      },
      kill: function(nick, reason, message, over) {
        var buffer, queue, _fn, _i, _len, _ref1,
          _this = this;

        queue = new WorkingQueue(1);
        _ref1 = this.buffersForMember(nick);
        _fn = function(buffer) {
          return queue.perform(function(bufferOver) {
            if (buffer instanceof ChannelBuffer) {
              buffer.removeMember(nick);
            }
            return buffer.addEvent({
              type: 'kill',
              from: nick,
              reason: message
            }, bufferOver);
          });
        };
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          _fn(buffer);
        }
        queue.onceDone(over);
        return queue.doneAddingJobs();
      },
      selfMessageOrAction: function(type, to, text, over) {
        var buffer,
          _this = this;

        if (to.match(/^[&#]/)) {
          if (buffer = this.getBuffer(to)) {
            return buffer.addEvent({
              type: type,
              from: this.getNick(),
              chan: to,
              msg: text,
              highlight: false,
              self: true
            }, over);
          } else {
            return over();
          }
        } else {
          return this.getOrCreateBuffer(to, 'conversation', function(buffer) {
            if (!buffer) {
              return over();
            }
            return buffer.unarchive(function() {
              return buffer.addEvent({
                type: type,
                from: _this.getNick(),
                msg: text,
                highlight: false,
                self: true
              }, over);
            });
          });
        }
      },
      selfMessage: function(to, text, over) {
        return this.signalHandlers.selfMessageOrAction.apply(this, ['buffer_msg', to, text, over]);
      },
      selfAction: function(to, text, over) {
        return this.signalHandlers.selfMessageOrAction.apply(this, ['buffer_me_msg', to, text, over]);
      },
      message: function(nick, to, text, message, over) {
        var buffer, bufferName, highlight,
          _this = this;

        if (to.match(/^[&#]/)) {
          if (buffer = this.getBuffer(to)) {
            highlight = this.shouldHighlight(text);
            return buffer.addEvent({
              type: 'buffer_msg',
              from: nick,
              chan: to,
              msg: text,
              highlight: highlight,
              self: false
            }, over);
          } else {
            return over();
          }
        } else {
          bufferName = nick === this.getNick() ? to : nick;
          highlight = nick !== this.getNick();
          return this.getOrCreateBuffer(bufferName, 'conversation', function(buffer) {
            return buffer.unarchive(function() {
              return buffer.addEvent({
                type: 'buffer_msg',
                from: nick,
                msg: text,
                highlight: highlight,
                self: false
              }, over);
            });
          });
        }
      },
      action: function(from, to, text, over) {
        var buffer, bufferName, isChannel;

        isChannel = to.match(/^[&#]/);
        bufferName = isChannel ? to : from;
        buffer = this.getBuffer(bufferName);
        if (buffer) {
          return buffer.addEvent({
            type: 'buffer_me_msg',
            from: from,
            msg: text
          }, over);
        } else {
          return over();
        }
      },
      notice: function(from, to, text, message, over) {
        var addEvent, buffer, bufferName, _ref1,
          _this = this;

        addEvent = function(buffer) {
          return buffer.addEvent({
            type: 'notice',
            msg: text,
            from: from,
            target: to
          }, over);
        };
        if (!from) {
          return addEvent(this.consoleBuffer);
        } else {
          bufferName = to === this.getNick() ? from : to;
          if (bufferName.match(/^[&#]/)) {
            buffer = (_ref1 = this.getBuffer(bufferName)) != null ? _ref1 : this.consoleBuffer;
            return addEvent(buffer);
          } else {
            return this.getOrCreateBuffer(bufferName, 'conversation', addEvent);
          }
        }
      },
      nick: function(oldnick, newnick, message, over) {
        var buffer, queue, _fn, _i, _len, _ref1,
          _this = this;

        queue = new WorkingQueue(1);
        _ref1 = this.buffersForMember(oldnick);
        _fn = function(buffer) {
          return queue.perform(function(addEventOver) {
            if (buffer instanceof ChannelBuffer) {
              buffer.renameMember(oldnick, newnick);
            }
            return buffer.addEvent({
              type: 'nickchange',
              newnick: newnick,
              oldnick: oldnick
            }, addEventOver);
          });
        };
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          _fn(buffer);
        }
        queue.onceDone(over);
        return queue.doneAddingJobs();
      },
      selfNick: function(oldnick, newnick, message, over) {
        var buffer, queue, _fn, _i, _len, _ref1,
          _this = this;

        queue = new WorkingQueue(1);
        queue.perform(function(addEventOver) {
          return _this.consoleBuffer.addEvent({
            type: 'you_nickchange',
            newnick: newnick,
            oldnick: oldnick
          }, addEventOver);
        });
        _ref1 = this.buffersForMember(oldnick);
        _fn = function(buffer) {
          return queue.perform(function(addEventOver) {
            if (buffer instanceof ChannelBuffer) {
              buffer.renameMember(oldnick, newnick);
            }
            return buffer.addEvent({
              type: 'you_nickchange',
              newnick: newnick,
              oldnick: oldnick
            }, addEventOver);
          });
        };
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          buffer = _ref1[_i];
          _fn(buffer);
        }
        queue.onceDone(over);
        return queue.doneAddingJobs();
      },
      invite: function(channel, from, message, over) {
        return this.consoleBuffer.addEvent({
          type: 'channel_invite',
          channel: channel,
          from: from
        }, over);
      },
      sendLine: function(message, over) {
        Log.silly("IRC SEND [" + (this.getName()) + "]: " + message);
        return over();
      },
      recvLine: function(message, over) {
        Log.silly("IRC RECV [" + (this.getName()) + "]: " + message);
        return over();
      },
      invalidCert: function(cert, error, callback, over) {
        if (this.sslFingerprint === cert.fingerprint) {
          callback(true);
          return over();
        } else {
          this.pendingSSLFingerprint = cert.fingerprint;
          this.pendingSSLCallback = callback;
          return this.user.broadcast({
            cid: this.id,
            type: 'invalid_cert',
            hostname: this.getHostName(),
            fingerprint: cert.fingerprint,
            error: error
          }, over);
        }
      },
      netError: function(error, over) {
        Log.error("Net error [" + (this.getName()) + "]: " + error + " " + error.stack);
        return this.consoleBuffer.addEvent({
          type: 'error',
          msg: error
        }, over);
      },
      error: function(error, over) {
        Log.error("Error [" + (this.getName()) + "]: " + error.stack);
        return this.consoleBuffer.addEvent({
          type: 'error',
          msg: (error.args ? error.args.join(' ') : error)
        }, over);
      }
    };

    return Connection;

  })(EventEmitter);

  module.exports = Connection;

}).call(this);
