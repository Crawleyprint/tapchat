// Generated by CoffeeScript 1.6.2
(function() {
  var B, Base64, Buffer, CoffeeScript, Config, Connection, Log, User, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, _ref;

  WorkingQueue = require('capisce').WorkingQueue;

  Log = require('./log');

  Config = require('./config');

  Base64 = require('../base64');

  B = require('./message_builder');

  Buffer = require('./buffer');

  Connection = require('./connection');

  CoffeeScript = require('coffee-script');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  User = (function() {
    function User(engine, info) {
      var _this = this;

      this.connections = [];
      this.clients = [];
      this.engine = engine;
      this.id = info.uid;
      this.name = info.name;
      this.is_admin = !!info.is_admin;
      this.engine.db.selectConnections(this.id, function(conns) {
        var connInfo, _i, _len, _results;

        _results = [];
        for (_i = 0, _len = conns.length; _i < _len; _i++) {
          connInfo = conns[_i];
          _results.push(_this.addConnection(connInfo));
        }
        return _results;
      });
    }

    User.prototype.edit = function(options, callback) {
      var _this = this;

      return this.engine.db.updateUser(this.id, options, function(row) {
        _this.updateAttributes(row);
        return callback(row);
      });
    };

    User.prototype.updateAttributes = function(options) {
      return this.is_admin = !!options.is_admin;
    };

    User.prototype.asJson = function() {
      return {
        id: this.id,
        name: this.name,
        is_admin: this.is_admin
      };
    };

    User.prototype.addClient = function(client, inbandBacklog) {
      var _this = this;

      client.sendQueue = new WorkingQueue(1);
      this.clients.push(client);
      client.onmessage = function(event) {
        var callback, error, handler, message;

        message = JSON.parse(event.data);
        if (!message._reqid) {
          Log.error('Missing _reqid, ignoring message', event.data);
          return;
        }
        Log.silly('Got message:', event.data);
        callback = function(reply) {
          return _this.send(client, {
            _reqid: message._reqid,
            msg: merge(reply, {
              success: true
            })
          });
        };
        if (handler = _this.messageHandlers[message._method]) {
          try {
            return handler.apply(_this, [client, message, callback]);
          } catch (_error) {
            error = _error;
            Log.error("Error handling message", {
              message: event.data,
              error: error.stack
            });
            return client.close();
          }
        } else {
          return Log.warn("No handler for " + message._method);
        }
      };
      client.onclose = function(event) {
        var index;

        Log.info('websocket client: disconnected', {
          code: event.code,
          reason: event.reason
        });
        index = _this.clients.indexOf(client);
        return _this.clients.splice(index, 1);
      };
      this.send(client, {
        type: 'header',
        version_name: Config.getAppVersion(),
        version_code: Config.getAppVersionCode(),
        idle_interval: 29000,
        push_id: this.pushId,
        push_key: Base64.urlEncode(this.pushKey)
      });
      this.send(client, {
        type: 'stat_user',
        id: this.id,
        name: this.name,
        is_admin: this.is_admin
      });
      if (!inbandBacklog) {
        return this.send(client, {
          type: 'oob_include',
          url: '/chat/backlog'
        });
      } else {
        return this.sendBacklog(client);
      }
    };

    User.prototype.removeClient = function(client) {
      client.close();
      return this.clients.splice(this.clients.indexOf(client), 1);
    };

    User.prototype.send = function(client, message, cb) {
      var json,
        _this = this;

      message = this.prepareMessage(message);
      json = JSON.stringify(message);
      Log.silly('CLIENT SEND:', json);
      client.sendQueue.perform(function(over) {
        return client.send(json, cb ? cb() : void 0, over());
      });
      return message;
    };

    User.prototype.prepareMessage = function(message) {
      var now;

      now = parseInt(Date.now() / 1000);
      if (!message.time) {
        message.time = now;
      }
      if (!message.highlight) {
        message.highlight = false;
      }
      if (!message.eid) {
        message.eid = -1;
      }
      return message;
    };

    User.prototype.addConnection = function(options) {
      var _this = this;

      return new Connection(this, this.engine, options, function(conn) {
        _this.connections.push(conn);
        conn.addListener('event', function(event) {
          return _this.broadcast(event);
        });
        return conn.sendBacklog(null, function() {
          if (conn.autoConnect) {
            return conn.connect();
          }
        });
      });
    };

    User.prototype.removeConnection = function(conn, cb) {
      var _this = this;

      return conn["delete"](function() {
        _this.connections.splice(_this.connections.indexOf(conn), 1);
        _this.broadcast(B.connectionDeleted(conn));
        return cb();
      });
    };

    User.prototype.findConnection = function(cid) {
      var conn, _i, _len, _ref1;

      _ref1 = this.connections;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        if (conn.id === cid) {
          return conn;
        }
      }
      return null;
    };

    User.prototype.broadcast = function(message, cb) {
      var client, queue, _fn, _i, _len, _ref1,
        _this = this;

      queue = new WorkingQueue(this.clients.length + 1);
      Log.silly('BROADCAST', JSON.stringify(message));
      if (!message.is_backlog) {
        if (message.highlight) {
          queue.perform(function(over) {
            return _this.pushClient.sendPush(message, over);
          });
        }
      }
      _ref1 = this.clients;
      _fn = function(client) {
        return queue.perform(function(over) {
          return _this.send(client, message, over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        client = _ref1[_i];
        _fn(client);
      }
      if (cb) {
        queue.onceDone(cb);
      }
      queue.doneAddingJobs();
      return message;
    };

    User.prototype.sendBacklog = function(client) {
      var _this = this;

      return this.getBacklog(function(event) {
        return _this.send(client, event);
      });
    };

    User.prototype.getBacklog = function(callback, done) {
      var conn, queue, _fn, _i, _len, _ref1,
        _this = this;

      queue = new WorkingQueue(1);
      _ref1 = this.connections;
      _fn = function(conn) {
        return queue.perform(function(over) {
          return conn.getBacklog((function(event) {
            return callback(event);
          }), over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        _fn(conn);
      }
      queue.onceDone(function() {
        callback({
          type: 'backlog_complete'
        });
        if (done) {
          return done();
        }
      });
      return queue.doneAddingJobs();
    };

    User.prototype["delete"] = function(cb) {
      var client, conn, queue, _fn, _i, _j, _len, _len1, _ref1, _ref2,
        _this = this;

      queue = new WorkingQueue(1);
      _ref1 = this.clients;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        client = _ref1[_i];
        this.removeClient(client);
      }
      _ref2 = this.connections;
      _fn = function(conn) {
        return queue.perform(function(over) {
          return _this.removeConnection(conn, over);
        });
      };
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        conn = _ref2[_j];
        _fn(conn);
      }
      queue.onceDone(function() {
        return _this.engine.db.deleteUser(_this.id, function() {
          if (cb) {
            return cb();
          }
        });
      });
      return queue.doneAddingJobs();
    };

    User.prototype.messageHandlers = {
      heartbeat: function(client, message, callback) {
        var bid, buffer, buffers, cid, connection, eid, queue, seenEids, _fn,
          _this = this;

        this.selectedBid = message.selectedBuffer;
        seenEids = JSON.parse(message.seenEids);
        queue = new WorkingQueue(1);
        for (cid in seenEids) {
          buffers = seenEids[cid];
          connection = this.findConnection(parseInt(cid));
          if (!connection) {
            throw "connection not found: " + cid;
          }
          _fn = function(buffer, eid) {
            return queue.perform(function(over) {
              return buffer.setLastSeenEid(eid, over);
            });
          };
          for (bid in buffers) {
            eid = buffers[bid];
            buffer = connection.findBuffer(parseInt(bid));
            if (!buffer) {
              throw "buffer not found: " + bid;
            }
            _fn(buffer, eid);
          }
        }
        queue.onceDone(function() {
          return _this.engine.db.getAllLastSeenEids(_this.id, function(updatedSeenEids) {
            return _this.send(client, {
              type: 'heartbeat_echo',
              seenEids: updatedSeenEids
            });
          });
        });
        return queue.doneAddingJobs();
      },
      say: function(client, message, callback) {
        var conn, text, to;

        conn = this.findConnection(message.cid);
        to = message.to;
        text = message.msg;
        if (to === '*') {
          conn.consoleBuffer.addEvent({
            type: 'error',
            msg: 'Commands not yet supported.'
          }, callback);
          return;
        }
        if (text) {
          conn.say(to, text);
          return;
        }
        return conn.getOrCreateBuffer(to, 'conversation', function(buffer, created) {
          return callback({
            name: to,
            cid: conn.id,
            type: 'open_buffer',
            _reqid: message._reqid
          });
        });
      },
      join: function(client, message, callback) {
        var chan, conn;

        chan = message.channel;
        conn = this.findConnection(message.cid);
        conn.join(chan);
        return callback({
          name: chan,
          cid: conn.id,
          type: 'open_buffer'
        });
      },
      part: function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        conn.part(message.channel);
        return callback();
      },
      disconnect: function(client, message, callback) {
        return this.findConnection(message.cid).disconnect(function() {
          return callback();
        });
      },
      reconnect: function(client, message, callback) {
        var _this = this;

        return this.findConnection(message.cid).reconnect(function() {
          return callback();
        });
      },
      'add-server': function(client, message, callback) {
        var _this = this;

        return this.engine.db.insertConnection(this.id, message, function(info) {
          _this.addConnection(info);
          return callback();
        });
      },
      'edit-server': function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        return conn.edit(message, callback);
      },
      'delete-connection': function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        return this.removeConnection(conn, callback);
      },
      'archive-buffer': function(client, message, callback) {
        var buffer, conn;

        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.archive(callback);
      },
      'unarchive-buffer': function(client, message, callback) {
        var buffer, conn;

        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.unarchive(callback);
      },
      'delete-buffer': function(client, message, callback) {
        var buffer, conn;

        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer["delete"](callback);
      },
      'accept-cert': function(client, message, callback) {
        var conn;

        conn = this.findConnection(message.cid);
        return conn.acceptCert(message.fingerprint, message.accept, callback);
      }
    };

    return User;

  })();

  module.exports = User;

}).call(this);
